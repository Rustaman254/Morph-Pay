"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidIdentityTokenError = void 0;
exports.parseUserFromIdentityTokenPayload = parseUserFromIdentityTokenPayload;
const error_1 = require("../error.js");
/**
 * Parses the payload of an identity token (JWT) into a `User` object.
 * Note that the user object may be incomplete due to the size constraints of the identity token.
 *
 * @param payload The payload of the identity token.
 * @returns The user object parsed from the identity token.
 * @throws If the payload is invalid.
 */
function parseUserFromIdentityTokenPayload(payload) {
    const customMetadata = parseCustomMetadataClaim(payload);
    return {
        id: payload.sub,
        created_at: parseInt(payload['cr']),
        is_guest: payload['guest'] === 't',
        linked_accounts: parseLinkedAccountsClaim(payload),
        ...(customMetadata ? { custom_metadata: customMetadata } : {}),
        has_accepted_terms: false,
        mfa_methods: [],
    };
}
function parseLinkedAccountsClaim(payload) {
    const linkedAccountsClaim = payload['linked_accounts'];
    if (typeof linkedAccountsClaim !== 'string') {
        throw new InvalidIdentityTokenError('Unable to parse identity token');
    }
    const parsedLinkedAccounts = JSON.parse(linkedAccountsClaim);
    if (!Array.isArray(parsedLinkedAccounts)) {
        throw new InvalidIdentityTokenError('Unable to parse identity token');
    }
    return parsedLinkedAccounts
        .map(mapIdLinkedAccountToUserLinkedAccount)
        .filter((account) => account !== null);
}
function mapIdLinkedAccountToUserLinkedAccount(account) {
    if (account.type === 'email') {
        return {
            type: 'email',
            address: account.address,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'phone') {
        return {
            type: 'phone',
            phoneNumber: account.phone_number,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    // Parses all wallet types
    if (account.type === 'wallet') {
        if (account.wallet_client_type === 'privy') {
            return {
                type: 'wallet',
                wallet_client_type: 'privy',
                wallet_client: 'privy',
                connector_type: 'embedded',
                id: account.id,
                address: account.address,
                chain_type: account.chain_type,
                first_verified_at: null,
                verified_at: account.lv,
                latest_verified_at: account.lv,
                // The following fields are not present in the identity token,
                // but are required. We set them to some safe defaults.
                chain_id: '',
                delegated: false,
                imported: false,
                public_key: '',
                wallet_index: 0,
                recovery_method: account.id ? 'privy-v2' : 'privy',
            };
        }
        return {
            type: 'wallet',
            wallet_client: 'unknown',
            address: account.address,
            chain_type: account.chain_type,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'smart_wallet') {
        return {
            type: 'smart_wallet',
            address: account.address,
            smart_wallet_type: account.smart_wallet_type,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'farcaster') {
        return {
            type: 'farcaster',
            fid: account.fid,
            username: account.username,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
            owner_address: account.oa,
        };
    }
    if (account.type === 'google_oauth') {
        return {
            type: 'google_oauth',
            subject: account.subject,
            email: account.email,
            name: account.name,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'twitter_oauth') {
        // We send along three potential URL shapes here based on possible profile picture URLs, all
        // done to preserve size.
        //   1. pfp begins with `default`, in which case we use the default profile picture URL structure
        //   2. pfp does not start with https, in which case we assume the profile picture URL structure
        //   3. Otherwise, we use the pfp URL as-is
        let pfp = account.pfp ? account.pfp : null;
        if (pfp?.startsWith('default')) {
            pfp = `https://abs.twimg.com/sticky/default_profile_images/${pfp}`;
        }
        else if (!pfp?.startsWith('https://')) {
            pfp = `https://pbs.twimg.com/profile_images/${pfp}`;
        }
        return {
            type: 'twitter_oauth',
            subject: account.subject,
            username: account.username,
            name: account.name ? account.name : null,
            profile_picture_url: pfp,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'discord_oauth') {
        return {
            type: 'discord_oauth',
            subject: account.subject,
            username: account.username,
            email: null, // not a part of the identity token
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'github_oauth') {
        return {
            type: 'github_oauth',
            subject: account.subject,
            username: account.username,
            email: null, // not a part of the identity token
            name: null, // not a part of the identity token
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'spotify_oauth') {
        return {
            type: 'spotify_oauth',
            subject: account.subject,
            email: null, // not a part of the identity token
            name: null, // not a part of the identity token
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'instagram_oauth') {
        return {
            type: 'instagram_oauth',
            subject: account.subject,
            username: account.username,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'tiktok_oauth') {
        return {
            type: 'tiktok_oauth',
            subject: account.subject,
            username: account.username,
            name: null, // not a part of the identity token
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'linkedin_oauth') {
        return {
            type: 'linkedin_oauth',
            subject: account.subject,
            email: account.email,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'apple_oauth') {
        return {
            type: 'apple_oauth',
            subject: account.subject,
            email: account.email,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'cross_app') {
        return {
            type: 'cross_app',
            subject: account.subject,
            provider_app_id: account.provider_app_id,
            embedded_wallets: account.embedded_wallets,
            smart_wallets: account.smart_wallets,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'custom_auth') {
        return {
            type: 'custom_auth',
            custom_user_id: account.custom_user_id,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    if (account.type === 'telegram') {
        return {
            type: 'telegram',
            telegram_user_id: account.telegram_user_id,
            username: account.username,
            first_verified_at: null,
            verified_at: account.lv,
            latest_verified_at: account.lv,
        };
    }
    return null;
}
function parseCustomMetadataClaim(payload) {
    const customMetadataClaim = payload['custom_metadata'];
    if (customMetadataClaim === undefined) {
        return undefined;
    }
    if (typeof customMetadataClaim !== 'string') {
        throw new InvalidIdentityTokenError('Unable to parse identity token');
    }
    const parsedCustomMetadata = JSON.parse(customMetadataClaim);
    if (!parsedCustomMetadata || typeof parsedCustomMetadata !== 'object') {
        throw new InvalidIdentityTokenError('Unable to parse identity token');
    }
    return parsedCustomMetadata;
}
class InvalidIdentityTokenError extends error_1.PrivyAPIError {
}
exports.InvalidIdentityTokenError = InvalidIdentityTokenError;
//# sourceMappingURL=identity-token.js.map