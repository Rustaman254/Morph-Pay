import { PrivyClient } from "../public-api/PrivyClient.mjs";
/**
 * The authorization context should contain:
 * - Any authorization private keys that must sign the request
 * - The JWTs for any users that must sign the request
 * - Any additional signatures you have computed for the request
 *
 * The Privy client will accept the authorization context, sign the request given the parameters,
 * and include all signatures in the privy-authorization-signature header to the API.
 */
export interface AuthorizationContext {
    /**
     * The private keys to use for authorization.
     * These should be base64-encoded PKCS8-formatted private keys, with no PEM headers.
     */
    authorization_private_keys?: string[];
    /**
     * The JWTs for the users that should sign the request authorization.
     * These should be valid JWTs for the user.
     */
    user_jwts?: string[];
    /**
     * The signatures that should be used for authorization.
     * These should be base64-encoded signatures.
     */
    signatures?: string[];
    /**
     * Sign functions can be used to sign requests directly, by managing the private keys and signing
     * logic externally.
     *
     * Sign functions should perform an ECDSA P-256 signature on the payload received, and return the
     * base64-encoded signature.
     */
    sign_fns?: AuthorizationContext.SignFn[];
}
export declare namespace AuthorizationContext {
    type SignFn = (payload: Uint8Array) => Promise<string>;
}
export type WalletApiRequestSignatureInput = {
    /** Signature version. 1 is currently the only valid version. */
    version: 1;
    /** Request method. Signatures are not required on 'GET' requests. */
    method: 'POST' | 'PUT' | 'PATCH' | 'DELETE';
    /** URL for the request. Should not contain a trailing slash. */
    url: string;
    /** Request body. */
    body: any;
    /** Privy-specific headers. */
    headers: {
        'privy-app-id': string;
        'privy-idempotency-key'?: string;
    };
};
/**
 * Formats the request payload into the expected authorization payload, canconicalizes it,
 * and encodes the JSON string into bytes.
 *
 * @param request The request to be formatted.
 * @return The raw bytes representing the authorization payload.
 */
export declare function formatRequestForAuthorizationSignature(input: WalletApiRequestSignatureInput): Uint8Array;
/**
 * Generates authorization signatures from the given authorization context and signable request.
 * This method handles JWT exchange and private key signing.
 *
 * Manual signing of requests is intended for advanced use cases.
 *
 * @param authorizationContext The authorization context containing JWTs, private keys, and signatures.
 * @param input The request payload to sign.
 * @returns An array of authorization signatures.
 */
export declare function generateAuthorizationSignatures(client: PrivyClient, { authorizationContext, input, }: {
    authorizationContext: AuthorizationContext;
    input: WalletApiRequestSignatureInput;
}): Promise<string[]>;
/**
 * Signs the given request with the provided private key.
 *
 * @param authorizationPrivateKey The base64-encoded PKCS8-formatted private key, with no PEM headers.
 * @param input The request payload to sign, or one serialized using {@link formatRequestForAuthorizationSignature}.
 * @return The authorization signature.
 */
export declare function generateAuthorizationSignature({ authorizationPrivateKey, input, }: {
    authorizationPrivateKey: string;
    input: WalletApiRequestSignatureInput | Uint8Array;
}): string;
//# sourceMappingURL=authorization.d.mts.map