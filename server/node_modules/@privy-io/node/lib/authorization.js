"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatRequestForAuthorizationSignature = formatRequestForAuthorizationSignature;
exports.generateAuthorizationSignatures = generateAuthorizationSignatures;
exports.generateAuthorizationSignature = generateAuthorizationSignature;
const tslib_1 = require("../internal/tslib.js");
const nist_1 = require("@noble/curves/nist");
const sha2_1 = require("@noble/hashes/sha2");
const canonicalize_1 = tslib_1.__importDefault(require("canonicalize"));
const error_1 = require("../core/error.js");
const cryptography_1 = require("./cryptography.js");
/**
 * Formats the request payload into the expected authorization payload, canconicalizes it,
 * and encodes the JSON string into bytes.
 *
 * @param request The request to be formatted.
 * @return The raw bytes representing the authorization payload.
 */
function formatRequestForAuthorizationSignature(input) {
    const body = input.body;
    if (typeof body === 'object' && body !== null && Object.keys(body).length === 0) {
        // This is a special case, where if the body is empty, we want to serialize it
        // as an empty string.
        input.body = '';
    }
    const serializedInput = (0, canonicalize_1.default)(input);
    if (!serializedInput) {
        throw new error_1.PrivyAPIError('Failed to serialize request for authorization signature');
    }
    return new TextEncoder().encode(serializedInput);
}
/**
 * Generates authorization signatures from the given authorization context and signable request.
 * This method handles JWT exchange and private key signing.
 *
 * Manual signing of requests is intended for advanced use cases.
 *
 * @param authorizationContext The authorization context containing JWTs, private keys, and signatures.
 * @param input The request payload to sign.
 * @returns An array of authorization signatures.
 */
async function generateAuthorizationSignatures(client, { authorizationContext, input, }) {
    const payload = formatRequestForAuthorizationSignature(input);
    const userJwts = authorizationContext.user_jwts ?? [];
    let userKeys = [];
    if (userJwts.length > 0) {
        userKeys = await Promise.all(userJwts.map((jwt) => client._jwtExchange().exchangeJwtForAuthorizationKey(jwt)));
    }
    /** These are the private keys provided by the caller, either directly or via JWT exchange */
    const privateKeys = [...(authorizationContext.authorization_private_keys ?? []), ...userKeys];
    /** These are the signatures calculated from the private keys */
    const calculatedSignatures = privateKeys.map((sk) => generateAuthorizationSignature({ authorizationPrivateKey: sk, input: payload }));
    /** These are the signatures calculated externally from the given sign functions */
    const signFnSignatures = await Promise.all((authorizationContext.sign_fns ?? []).map((signFn) => signFn(payload)));
    /** These are the signatures provided directly by the caller */
    const providedRawSignatures = authorizationContext.signatures ?? [];
    return [...providedRawSignatures, ...calculatedSignatures, ...signFnSignatures];
}
/**
 * Signs the given request with the provided private key.
 *
 * @param authorizationPrivateKey The base64-encoded PKCS8-formatted private key, with no PEM headers.
 * @param input The request payload to sign, or one serialized using {@link formatRequestForAuthorizationSignature}.
 * @return The authorization signature.
 */
function generateAuthorizationSignature({ authorizationPrivateKey, input, }) {
    const payload = input instanceof Uint8Array ? input : formatRequestForAuthorizationSignature(input);
    const privateKey = (0, cryptography_1.importPKCS8PrivateKey)(authorizationPrivateKey);
    const signature = nist_1.p256.sign((0, sha2_1.sha256)(payload), privateKey).toBytes('der');
    // We fall back to `Buffer` here as Uint8Array.toBase64 is not widely supported yet
    return Buffer.from(signature).toString('base64');
}
//# sourceMappingURL=authorization.js.map