import { createRemoteJWKSet, importSPKI, errors as joseErrors, jwtVerify, } from 'jose';
import { PrivyAPIError } from "../core/error.mjs";
import { parseUserFromIdentityTokenPayload } from "./identity-token.mjs";
const JWT_ALGORITHM = 'ES256';
const JWT_ISSUER = 'privy.io';
/**
 * Verifies a JWT issued by privy.io for the given app ID.
 * This serves both auth tokens and identity tokens.
 * @returns The verify result along with the token's payload.
 * @throws If the token is invalid.
 */
async function verifyPrivyIssuedJwt(jwt, appId, verificationKey) {
    // Because of a type difference, the calls cannot be merged into one.
    let verifiedToken;
    if (typeof verificationKey !== 'function') {
        verifiedToken = await jwtVerify(jwt, verificationKey, {
            typ: 'JWT',
            algorithms: [JWT_ALGORITHM],
            issuer: JWT_ISSUER,
            audience: appId,
        }).catch(mapAndThrowJoseErrors);
    }
    else {
        verifiedToken = await jwtVerify(jwt, verificationKey, {
            typ: 'JWT',
            algorithms: [JWT_ALGORITHM],
            issuer: JWT_ISSUER,
            audience: appId,
        }).catch(mapAndThrowJoseErrors);
    }
    return verifiedToken;
}
/**
 * Verifies a Privy-issued authentication token.
 *
 * @returns The payload of the token if it is valid.
 * @throws If the token is invalid.
 */
export async function verifyAuthToken({ auth_token: authToken, app_id: appId, verification_key: verificationKeyOrString, }) {
    const verificationKey = typeof verificationKeyOrString === 'string' ?
        await importSPKI(verificationKeyOrString, JWT_ALGORITHM)
        : verificationKeyOrString;
    const verifiedToken = await verifyPrivyIssuedJwt(authToken, appId, verificationKey);
    return {
        app_id: throwIfNotString(verifiedToken.payload.aud),
        issuer: throwIfNotString(verifiedToken.payload.iss),
        issued_at: throwIfNotNumber(verifiedToken.payload.iat),
        expiration: throwIfNotNumber(verifiedToken.payload.exp),
        session_id: throwIfNotString(verifiedToken.payload['sid']),
        user_id: throwIfNotString(verifiedToken.payload.sub),
    };
}
/**
 * Verifies an identity token, parsing it into a `User` object if it is valid.
 *
 * @returns The user object parsed from the identity token.
 * @throws If the token or its payload is invalid.
 */
export async function verifyIdentityToken({ identity_token: identityToken, app_id: appId, verification_key: verificationKeyOrString, }) {
    const verificationKey = typeof verificationKeyOrString === 'string' ?
        await importSPKI(verificationKeyOrString, JWT_ALGORITHM)
        : verificationKeyOrString;
    const verifiedToken = await verifyPrivyIssuedJwt(identityToken, appId, verificationKey);
    if (!verifiedToken.payload) {
        throw new InvalidAuthTokenError('Unable to parse identity token');
    }
    return parseUserFromIdentityTokenPayload(verifiedToken.payload);
}
export class InvalidAuthTokenError extends PrivyAPIError {
}
/** Used for asserting the values in the token payload are strings. */
function throwIfNotString(value) {
    if (!value || typeof value !== 'string') {
        throw new InvalidAuthTokenError("Token's payload is invalid");
    }
    return value;
}
/** Used for asserting the values in the token payload are numbers. */
function throwIfNotNumber(value) {
    if (!value || typeof value !== 'number') {
        throw new InvalidAuthTokenError("Token's payload is invalid");
    }
    return value;
}
/**
 * Used to catch errors thrown by async `jose` functions and map to our own error types.
 * This method will **always** throw an error, so it's return type is `never`.
 */
function mapAndThrowJoseErrors(error) {
    if (error instanceof joseErrors.JWTExpired) {
        throw new InvalidAuthTokenError('Authentication token expired');
    }
    else if (error instanceof joseErrors.JWTClaimValidationFailed || error instanceof joseErrors.JWTInvalid) {
        throw new InvalidAuthTokenError('Authentication token is invalid');
    }
    else {
        throw new InvalidAuthTokenError('Failed to verify authentication token');
    }
}
export function createPrivyAppJWKS({ appId, apiUrl, headers, verificationKeyOverride, }) {
    if (verificationKeyOverride !== undefined) {
        // Use a closure to cache the verification key once imported
        let verificationKey;
        return async () => {
            if (verificationKey === undefined) {
                try {
                    verificationKey = await importSPKI(verificationKeyOverride, JWT_ALGORITHM);
                }
                catch (error) {
                    throw new InvalidAuthTokenError('Failed to import the provided verification key override');
                }
            }
            return verificationKey;
        };
    }
    const url = new URL(`${apiUrl}/v1/apps/${appId}/jwks.json`);
    return createRemoteJWKSet(url, {
        cacheMaxAge: 60 * 60 * 1000, // 60 minutes
        cooldownDuration: 10 * 60 * 1000, // 10 minutes
        headers,
    });
}
//# sourceMappingURL=auth.mjs.map