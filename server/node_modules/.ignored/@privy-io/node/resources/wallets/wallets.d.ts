import { APIResource } from "../../core/resource.js";
import * as WalletsAPI from "./wallets.js";
import * as BalanceAPI from "./balance.js";
import { Balance, BalanceGetParams, BalanceGetResponse } from "./balance.js";
import * as TransactionsAPI from "./transactions.js";
import { TransactionGetParams, TransactionGetResponse, Transactions } from "./transactions.js";
import { APIPromise } from "../../core/api-promise.js";
import { Cursor, type CursorParams, PagePromise } from "../../core/pagination.js";
import { RequestOptions } from "../../internal/request-options.js";
export declare class Wallets extends APIResource {
    transactions: TransactionsAPI.Transactions;
    balance: BalanceAPI.Balance;
    /**
     * Create a new wallet.
     *
     * @example
     * ```ts
     * const wallet = await client.wallets.create({
     *   chain_type: 'ethereum',
     * });
     * ```
     */
    create(params: WalletCreateParams, options?: RequestOptions): APIPromise<Wallet>;
    /**
     * Get all wallets in your app.
     *
     * @example
     * ```ts
     * // Automatically fetches more pages as needed.
     * for await (const wallet of client.wallets.list()) {
     *   // ...
     * }
     * ```
     */
    list(query?: WalletListParams | null | undefined, options?: RequestOptions): PagePromise<WalletsCursor, Wallet>;
    /**
     * Export a wallet's private key
     *
     * @example
     * ```ts
     * const response = await client.wallets._export('wallet_id', {
     *   encryption_type: 'HPKE',
     *   recipient_public_key:
     *     'BDAZLOIdTaPycEYkgG0MvCzbIKJLli/yWkAV5yCa9yOsZ4JsrLweA5MnP8YIiY4k/RRzC+APhhO+P+Hoz/rt7Go=',
     * });
     * ```
     */
    _export(walletID: string, params: WalletExportParams, options?: RequestOptions): APIPromise<WalletExportResponse>;
    /**
     * Initialize a wallet import. Complete by submitting the import.
     *
     * @example
     * ```ts
     * const response = await client.wallets._initImport({
     *   address: 'address',
     *   chain_type: 'ethereum',
     *   encryption_type: 'HPKE',
     *   entropy_type: 'hd',
     *   index: 0,
     * });
     * ```
     */
    _initImport(body: WalletInitImportParams, options?: RequestOptions): APIPromise<WalletInitImportResponse>;
    /**
     * Sign a message with a wallet by wallet ID.
     *
     * @example
     * ```ts
     * const response = await client.wallets._rawSign(
     *   'wallet_id',
     *   { params: {} },
     * );
     * ```
     */
    _rawSign(walletID: string, params: WalletRawSignParams, options?: RequestOptions): APIPromise<WalletRawSignResponse>;
    /**
     * Sign a message or transaction with a wallet by wallet ID.
     *
     * @example
     * ```ts
     * const response = await client.wallets._rpc('wallet_id', {
     *   method: 'eth_signTransaction',
     *   params: { transaction: {} },
     * });
     * ```
     */
    _rpc(walletID: string, params: WalletRpcParams, options?: RequestOptions): APIPromise<WalletRpcResponse>;
    /**
     * Submit a wallet import request.
     *
     * @example
     * ```ts
     * const wallet = await client.wallets._submitImport({
     *   wallet: {
     *     address: '0xF1DBff66C993EE895C8cb176c30b07A559d76496',
     *     chain_type: 'ethereum',
     *     ciphertext:
     *       'PRoRXygG+YYSDBXjCopNYZmx8Z6nvdl1D0lpePTYZdZI2VGfK+LkFt+GlEJqdoi9',
     *     encapsulated_key:
     *       'BOhR6xITDt5THJawHHJKrKdI9CBr2M/SDWzZZAaOW4gCMsSpC65U007WyKiwuuOVAo1BNm4YgcBBROuMmyIZXZk=',
     *     encryption_type: 'HPKE',
     *     entropy_type: 'private-key',
     *   },
     * });
     * ```
     */
    _submitImport(body: WalletSubmitImportParams, options?: RequestOptions): APIPromise<Wallet>;
    /**
     * Update a wallet's policies or authorization key configuration.
     *
     * @example
     * ```ts
     * const wallet = await client.wallets._update('wallet_id');
     * ```
     */
    _update(walletID: string, params: WalletUpdateParams, options?: RequestOptions): APIPromise<Wallet>;
    /**
     * Obtain a session key to enable wallet access.
     *
     * @example
     * ```ts
     * const response = await client.wallets.authenticateWithJwt({
     *   user_jwt:
     *     'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30',
     * });
     * ```
     */
    authenticateWithJwt(body: WalletAuthenticateWithJwtParams, options?: RequestOptions): APIPromise<WalletAuthenticateWithJwtResponse>;
    /**
     * Create wallets with an associated recovery user.
     *
     * @deprecated
     */
    createWalletsWithRecovery(body: WalletCreateWalletsWithRecoveryParams, options?: RequestOptions): APIPromise<WalletCreateWalletsWithRecoveryResponse>;
    /**
     * Get a wallet by wallet ID.
     *
     * @example
     * ```ts
     * const wallet = await client.wallets.get('wallet_id');
     * ```
     */
    get(walletID: string, options?: RequestOptions): APIPromise<Wallet>;
}
export type WalletsCursor = Cursor<Wallet>;
export interface Wallet {
    /**
     * Unique ID of the wallet. This will be the primary identifier when using the
     * wallet in the future.
     */
    id: string;
    /**
     * Additional signers for the wallet.
     */
    additional_signers: Array<Wallet.AdditionalSigner>;
    /**
     * Address of the wallet.
     */
    address: string;
    /**
     * Chain type of the wallet
     */
    chain_type: 'solana' | 'ethereum' | 'cosmos' | 'stellar' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'spark' | 'ton' | 'starknet' | 'movement';
    /**
     * Unix timestamp of when the wallet was created in milliseconds.
     */
    created_at: number;
    /**
     * Unix timestamp of when the wallet was exported in milliseconds, if the wallet
     * was exported.
     */
    exported_at: number | null;
    /**
     * Unix timestamp of when the wallet was imported in milliseconds, if the wallet
     * was imported.
     */
    imported_at: number | null;
    /**
     * List of policy IDs for policies that are enforced on the wallet.
     */
    policy_ids: Array<string>;
    /**
     * The key quorum ID of the owner of the wallet.
     */
    owner_id?: string;
    /**
     * The compressed, raw public key for the wallet along the chain cryptographic
     * curve.
     */
    public_key?: string;
}
export declare namespace Wallet {
    interface AdditionalSigner {
        override_policy_ids: Array<string>;
        signer_id: string;
    }
}
export interface WalletExportResponse {
    /**
     * The encrypted private key.
     */
    ciphertext: string;
    /**
     * The base64-encoded encapsulated key that was generated during encryption, for
     * use during decryption.
     */
    encapsulated_key: string;
    /**
     * The encryption type of the wallet to import. Currently only supports `HPKE`.
     */
    encryption_type: 'HPKE';
}
export interface WalletInitImportResponse {
    /**
     * The base64-encoded encryption public key to encrypt the wallet entropy with.
     */
    encryption_public_key: string;
    /**
     * The encryption type of the wallet to import. Currently only supports `HPKE`.
     */
    encryption_type: 'HPKE';
}
export interface WalletRawSignResponse {
    data: WalletRawSignResponse.Data;
}
export declare namespace WalletRawSignResponse {
    interface Data {
        encoding: 'hex';
        signature: string;
    }
}
export type WalletRpcResponse = WalletRpcResponse.SolanaSignTransactionRpcResponse | WalletRpcResponse.SolanaSignAndSendTransactionRpcResponse | WalletRpcResponse.SolanaSignMessageRpcResponse | WalletRpcResponse.EthereumSignTransactionRpcResponse | WalletRpcResponse.EthereumSendTransactionRpcResponse | WalletRpcResponse.EthereumPersonalSignRpcResponse | WalletRpcResponse.EthereumSignTypedDataRpcResponse | WalletRpcResponse.EthereumSign7702AuthorizationRpcResponse | WalletRpcResponse.EthereumSecp256k1SignRpcResponse;
export declare namespace WalletRpcResponse {
    interface SolanaSignTransactionRpcResponse {
        data: SolanaSignTransactionRpcResponse.Data;
        method: 'signTransaction';
    }
    namespace SolanaSignTransactionRpcResponse {
        interface Data {
            encoding: 'base64';
            signed_transaction: string;
        }
    }
    interface SolanaSignAndSendTransactionRpcResponse {
        data: SolanaSignAndSendTransactionRpcResponse.Data;
        method: 'signAndSendTransaction';
    }
    namespace SolanaSignAndSendTransactionRpcResponse {
        interface Data {
            caip2: string;
            hash: string;
            transaction_id?: string;
        }
    }
    interface SolanaSignMessageRpcResponse {
        data: SolanaSignMessageRpcResponse.Data;
        method: 'signMessage';
    }
    namespace SolanaSignMessageRpcResponse {
        interface Data {
            encoding: 'base64';
            signature: string;
        }
    }
    interface EthereumSignTransactionRpcResponse {
        data: EthereumSignTransactionRpcResponse.Data;
        method: 'eth_signTransaction';
    }
    namespace EthereumSignTransactionRpcResponse {
        interface Data {
            encoding: 'rlp';
            signed_transaction: string;
        }
    }
    interface EthereumSendTransactionRpcResponse {
        data: EthereumSendTransactionRpcResponse.Data;
        method: 'eth_sendTransaction';
    }
    namespace EthereumSendTransactionRpcResponse {
        interface Data {
            caip2: string;
            hash: string;
            transaction_id?: string;
            transaction_request?: Data.TransactionRequest;
        }
        namespace Data {
            interface TransactionRequest {
                chain_id?: string | number;
                data?: string;
                from?: string;
                gas_limit?: string | number;
                gas_price?: string | number;
                max_fee_per_gas?: string | number;
                max_priority_fee_per_gas?: string | number;
                nonce?: string | number;
                to?: string;
                type?: 0 | 1 | 2;
                value?: string | number;
            }
        }
    }
    interface EthereumPersonalSignRpcResponse {
        data: EthereumPersonalSignRpcResponse.Data;
        method: 'personal_sign';
    }
    namespace EthereumPersonalSignRpcResponse {
        interface Data {
            encoding: 'hex';
            signature: string;
        }
    }
    interface EthereumSignTypedDataRpcResponse {
        data: EthereumSignTypedDataRpcResponse.Data;
        method: 'eth_signTypedData_v4';
    }
    namespace EthereumSignTypedDataRpcResponse {
        interface Data {
            encoding: 'hex';
            signature: string;
        }
    }
    interface EthereumSign7702AuthorizationRpcResponse {
        data: EthereumSign7702AuthorizationRpcResponse.Data;
        method: 'eth_sign7702Authorization';
    }
    namespace EthereumSign7702AuthorizationRpcResponse {
        interface Data {
            authorization: Data.Authorization;
        }
        namespace Data {
            interface Authorization {
                chain_id: string | number;
                contract: string;
                nonce: string | number;
                r: string;
                s: string;
                y_parity: number;
            }
        }
    }
    interface EthereumSecp256k1SignRpcResponse {
        data: EthereumSecp256k1SignRpcResponse.Data;
        method: 'secp256k1_sign';
    }
    namespace EthereumSecp256k1SignRpcResponse {
        interface Data {
            encoding: 'hex';
            signature: string;
        }
    }
}
export type WalletAuthenticateWithJwtResponse = WalletAuthenticateWithJwtResponse.WithEncryption | WalletAuthenticateWithJwtResponse.WithoutEncryption;
export declare namespace WalletAuthenticateWithJwtResponse {
    interface WithEncryption {
        /**
         * The encrypted authorization key data.
         */
        encrypted_authorization_key: WithEncryption.EncryptedAuthorizationKey;
        /**
         * The expiration time of the authorization key in seconds since the epoch.
         */
        expires_at: number;
        wallets: Array<WalletsAPI.Wallet>;
    }
    namespace WithEncryption {
        /**
         * The encrypted authorization key data.
         */
        interface EncryptedAuthorizationKey {
            /**
             * The encrypted authorization key corresponding to the user's current
             * authentication session.
             */
            ciphertext: string;
            /**
             * Base64-encoded ephemeral public key used in the HPKE encryption process.
             * Required for decryption.
             */
            encapsulated_key: string;
            /**
             * The encryption type used. Currently only supports HPKE.
             */
            encryption_type: 'HPKE';
        }
    }
    interface WithoutEncryption {
        /**
         * The raw authorization key data.
         */
        authorization_key: string;
        /**
         * The expiration time of the authorization key in seconds since the epoch.
         */
        expires_at: number;
        wallets: Array<WalletsAPI.Wallet>;
    }
}
export interface WalletCreateWalletsWithRecoveryResponse {
    /**
     * The ID of the created user.
     */
    recovery_user_id: string;
    /**
     * The wallets that were created.
     */
    wallets: Array<Wallet>;
}
export interface WalletCreateParams {
    /**
     * Body param: Chain type of the wallet
     */
    chain_type: 'solana' | 'ethereum' | 'cosmos' | 'stellar' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'spark' | 'ton' | 'starknet' | 'movement';
    /**
     * Body param: Additional signers for the wallet.
     */
    additional_signers?: Array<WalletCreateParams.AdditionalSigner>;
    /**
     * Body param: The owner of the resource. If you provide this, do not specify an
     * owner_id as it will be generated automatically. When updating a wallet, you can
     * set the owner to null to remove the owner.
     */
    owner?: WalletCreateParams.PublicKeyOwner | WalletCreateParams.UserOwner | null;
    /**
     * Body param: The key quorum ID to set as the owner of the resource. If you
     * provide this, do not specify an owner.
     */
    owner_id?: string;
    /**
     * Body param: List of policy IDs for policies that should be enforced on the
     * wallet. Currently, only one policy is supported per wallet.
     */
    policy_ids?: Array<string>;
    /**
     * Header param: Idempotency keys ensure API requests are executed only once within
     * a 24-hour window.
     */
    'privy-idempotency-key'?: string;
}
export declare namespace WalletCreateParams {
    interface AdditionalSigner {
        override_policy_ids: Array<string>;
        signer_id: string;
    }
    /**
     * The P-256 public key of the owner of the resource. If you provide this, do not
     * specify an owner_id as it will be generated automatically.
     */
    interface PublicKeyOwner {
        public_key: string;
    }
    /**
     * The user ID of the owner of the resource. The user must already exist, and this
     * value must start with "did:privy:". If you provide this, do not specify an
     * owner_id as it will be generated automatically.
     */
    interface UserOwner {
        user_id: string;
    }
}
export interface WalletListParams extends CursorParams {
    chain_type?: 'cosmos' | 'stellar' | 'sui' | 'aptos' | 'movement' | 'tron' | 'bitcoin-segwit' | 'near' | 'ton' | 'starknet' | 'spark' | 'solana' | 'ethereum';
    user_id?: string;
}
export interface WalletExportParams {
    /**
     * Body param: The encryption type of the wallet to import. Currently only supports
     * `HPKE`.
     */
    encryption_type: 'HPKE';
    /**
     * Body param: The base64-encoded encryption public key to encrypt the wallet
     * private key with.
     */
    recipient_public_key: string;
    /**
     * Header param: Request authorization signature. If multiple signatures are
     * required, they should be comma separated.
     */
    'privy-authorization-signature'?: string;
}
export type WalletInitImportParams = WalletInitImportParams.HDInitInput | WalletInitImportParams.PrivateKeyInitInput;
export declare namespace WalletInitImportParams {
    interface HDInitInput {
        /**
         * The address of the wallet to import.
         */
        address: string;
        /**
         * The chain type of the wallet to import. Currently supports `ethereum` and
         * `solana`.
         */
        chain_type: 'ethereum' | 'solana';
        /**
         * The encryption type of the wallet to import. Currently only supports `HPKE`.
         */
        encryption_type: 'HPKE';
        /**
         * The entropy type of the wallet to import.
         */
        entropy_type: 'hd';
        /**
         * The index of the wallet to import.
         */
        index: number;
    }
    interface PrivateKeyInitInput {
        /**
         * The address of the wallet to import.
         */
        address: string;
        /**
         * The chain type of the wallet to import. Currently supports `ethereum` and
         * `solana`.
         */
        chain_type: 'ethereum' | 'solana';
        /**
         * The encryption type of the wallet to import. Currently only supports `HPKE`.
         */
        encryption_type: 'HPKE';
        entropy_type: 'private-key';
    }
}
export interface WalletRawSignParams {
    /**
     * Body param:
     */
    params: WalletRawSignParams.Params;
    /**
     * Header param: Request authorization signature. If multiple signatures are
     * required, they should be comma separated.
     */
    'privy-authorization-signature'?: string;
    /**
     * Header param: Idempotency keys ensure API requests are executed only once within
     * a 24-hour window.
     */
    'privy-idempotency-key'?: string;
}
export declare namespace WalletRawSignParams {
    interface Params {
        /**
         * The hash to sign. Must start with `0x`.
         */
        hash?: string;
    }
}
export type WalletRpcParams = WalletRpcParams.EthereumSignTransactionRpcInput | WalletRpcParams.EthereumSendTransactionRpcInput | WalletRpcParams.EthereumPersonalSignRpcInput | WalletRpcParams.EthereumSignTypedDataRpcInput | WalletRpcParams.EthereumSign7702AuthorizationRpcInput | WalletRpcParams.EthereumSecp256k1SignRpcInput | WalletRpcParams.SolanaSignTransactionRpcInput | WalletRpcParams.SolanaSignAndSendTransactionRpcInput | WalletRpcParams.SolanaSignMessageRpcInput;
export declare namespace WalletRpcParams {
    interface EthereumSignTransactionRpcInput {
        /**
         * Body param:
         */
        method: 'eth_signTransaction';
        /**
         * Body param:
         */
        params: EthereumSignTransactionRpcInput.Params;
        /**
         * Body param:
         */
        address?: string;
        /**
         * Body param:
         */
        chain_type?: 'ethereum';
        /**
         * Header param: Request authorization signature. If multiple signatures are
         * required, they should be comma separated.
         */
        'privy-authorization-signature'?: string;
        /**
         * Header param: Idempotency keys ensure API requests are executed only once within
         * a 24-hour window.
         */
        'privy-idempotency-key'?: string;
    }
    namespace EthereumSignTransactionRpcInput {
        interface Params {
            transaction: Params.Transaction;
        }
        namespace Params {
            interface Transaction {
                chain_id?: string | number;
                data?: string;
                from?: string;
                gas_limit?: string | number;
                gas_price?: string | number;
                max_fee_per_gas?: string | number;
                max_priority_fee_per_gas?: string | number;
                nonce?: string | number;
                to?: string;
                type?: 0 | 1 | 2;
                value?: string | number;
            }
        }
    }
    interface EthereumSendTransactionRpcInput {
        /**
         * Body param:
         */
        caip2: string;
        /**
         * Body param:
         */
        method: 'eth_sendTransaction';
        /**
         * Body param:
         */
        params: EthereumSendTransactionRpcInput.Params;
        /**
         * Body param:
         */
        address?: string;
        /**
         * Body param:
         */
        chain_type?: 'ethereum';
        /**
         * Body param:
         */
        sponsor?: boolean;
        /**
         * Header param: Request authorization signature. If multiple signatures are
         * required, they should be comma separated.
         */
        'privy-authorization-signature'?: string;
        /**
         * Header param: Idempotency keys ensure API requests are executed only once within
         * a 24-hour window.
         */
        'privy-idempotency-key'?: string;
    }
    namespace EthereumSendTransactionRpcInput {
        interface Params {
            transaction: Params.Transaction;
        }
        namespace Params {
            interface Transaction {
                chain_id?: string | number;
                data?: string;
                from?: string;
                gas_limit?: string | number;
                gas_price?: string | number;
                max_fee_per_gas?: string | number;
                max_priority_fee_per_gas?: string | number;
                nonce?: string | number;
                to?: string;
                type?: 0 | 1 | 2;
                value?: string | number;
            }
        }
    }
    interface EthereumPersonalSignRpcInput {
        /**
         * Body param:
         */
        method: 'personal_sign';
        /**
         * Body param:
         */
        params: EthereumPersonalSignRpcInput.Params;
        /**
         * Body param:
         */
        address?: string;
        /**
         * Body param:
         */
        chain_type?: 'ethereum';
        /**
         * Header param: Request authorization signature. If multiple signatures are
         * required, they should be comma separated.
         */
        'privy-authorization-signature'?: string;
        /**
         * Header param: Idempotency keys ensure API requests are executed only once within
         * a 24-hour window.
         */
        'privy-idempotency-key'?: string;
    }
    namespace EthereumPersonalSignRpcInput {
        interface Params {
            encoding: 'utf-8' | 'hex';
            message: string;
        }
    }
    interface EthereumSignTypedDataRpcInput {
        /**
         * Body param:
         */
        method: 'eth_signTypedData_v4';
        /**
         * Body param:
         */
        params: EthereumSignTypedDataRpcInput.Params;
        /**
         * Body param:
         */
        address?: string;
        /**
         * Body param:
         */
        chain_type?: 'ethereum';
        /**
         * Header param: Request authorization signature. If multiple signatures are
         * required, they should be comma separated.
         */
        'privy-authorization-signature'?: string;
        /**
         * Header param: Idempotency keys ensure API requests are executed only once within
         * a 24-hour window.
         */
        'privy-idempotency-key'?: string;
    }
    namespace EthereumSignTypedDataRpcInput {
        interface Params {
            typed_data: Params.TypedData;
        }
        namespace Params {
            interface TypedData {
                domain: {
                    [key: string]: unknown;
                };
                message: {
                    [key: string]: unknown;
                };
                primary_type: string;
                types: {
                    [key: string]: Array<TypedData.Type>;
                };
            }
            namespace TypedData {
                interface Type {
                    name: string;
                    type: string;
                }
            }
        }
    }
    interface EthereumSign7702AuthorizationRpcInput {
        /**
         * Body param:
         */
        method: 'eth_sign7702Authorization';
        /**
         * Body param:
         */
        params: EthereumSign7702AuthorizationRpcInput.Params;
        /**
         * Body param:
         */
        address?: string;
        /**
         * Body param:
         */
        chain_type?: 'ethereum';
        /**
         * Header param: Request authorization signature. If multiple signatures are
         * required, they should be comma separated.
         */
        'privy-authorization-signature'?: string;
        /**
         * Header param: Idempotency keys ensure API requests are executed only once within
         * a 24-hour window.
         */
        'privy-idempotency-key'?: string;
    }
    namespace EthereumSign7702AuthorizationRpcInput {
        interface Params {
            chain_id: string | number;
            contract: string;
            nonce?: string | number;
        }
    }
    interface EthereumSecp256k1SignRpcInput {
        /**
         * Body param:
         */
        method: 'secp256k1_sign';
        /**
         * Body param:
         */
        params: EthereumSecp256k1SignRpcInput.Params;
        /**
         * Body param:
         */
        address?: string;
        /**
         * Body param:
         */
        chain_type?: 'ethereum';
        /**
         * Header param: Request authorization signature. If multiple signatures are
         * required, they should be comma separated.
         */
        'privy-authorization-signature'?: string;
        /**
         * Header param: Idempotency keys ensure API requests are executed only once within
         * a 24-hour window.
         */
        'privy-idempotency-key'?: string;
    }
    namespace EthereumSecp256k1SignRpcInput {
        interface Params {
            hash: string;
        }
    }
    interface SolanaSignTransactionRpcInput {
        /**
         * Body param:
         */
        method: 'signTransaction';
        /**
         * Body param:
         */
        params: SolanaSignTransactionRpcInput.Params;
        /**
         * Body param:
         */
        address?: string;
        /**
         * Body param:
         */
        chain_type?: 'solana';
        /**
         * Header param: Request authorization signature. If multiple signatures are
         * required, they should be comma separated.
         */
        'privy-authorization-signature'?: string;
        /**
         * Header param: Idempotency keys ensure API requests are executed only once within
         * a 24-hour window.
         */
        'privy-idempotency-key'?: string;
    }
    namespace SolanaSignTransactionRpcInput {
        interface Params {
            encoding: 'base64';
            transaction: string;
        }
    }
    interface SolanaSignAndSendTransactionRpcInput {
        /**
         * Body param:
         */
        caip2: string;
        /**
         * Body param:
         */
        method: 'signAndSendTransaction';
        /**
         * Body param:
         */
        params: SolanaSignAndSendTransactionRpcInput.Params;
        /**
         * Body param:
         */
        address?: string;
        /**
         * Body param:
         */
        chain_type?: 'solana';
        /**
         * Body param:
         */
        sponsor?: boolean;
        /**
         * Header param: Request authorization signature. If multiple signatures are
         * required, they should be comma separated.
         */
        'privy-authorization-signature'?: string;
        /**
         * Header param: Idempotency keys ensure API requests are executed only once within
         * a 24-hour window.
         */
        'privy-idempotency-key'?: string;
    }
    namespace SolanaSignAndSendTransactionRpcInput {
        interface Params {
            encoding: 'base64';
            transaction: string;
        }
    }
    interface SolanaSignMessageRpcInput {
        /**
         * Body param:
         */
        method: 'signMessage';
        /**
         * Body param:
         */
        params: SolanaSignMessageRpcInput.Params;
        /**
         * Body param:
         */
        address?: string;
        /**
         * Body param:
         */
        chain_type?: 'solana';
        /**
         * Header param: Request authorization signature. If multiple signatures are
         * required, they should be comma separated.
         */
        'privy-authorization-signature'?: string;
        /**
         * Header param: Idempotency keys ensure API requests are executed only once within
         * a 24-hour window.
         */
        'privy-idempotency-key'?: string;
    }
    namespace SolanaSignMessageRpcInput {
        interface Params {
            encoding: 'base64';
            message: string;
        }
    }
}
export interface WalletSubmitImportParams {
    wallet: WalletSubmitImportParams.HDSubmitInput | WalletSubmitImportParams.PrivateKeySubmitInput;
    additional_signers?: Array<WalletSubmitImportParams.AdditionalSigner>;
    owner?: WalletSubmitImportParams.UserID | WalletSubmitImportParams.PublicKey | null;
    owner_id?: string | null;
    policy_ids?: Array<string>;
}
export declare namespace WalletSubmitImportParams {
    interface HDSubmitInput {
        /**
         * The address of the wallet to import.
         */
        address: string;
        /**
         * The chain type of the wallet to import. Currently supports `ethereum` and
         * `solana`.
         */
        chain_type: 'ethereum' | 'solana';
        /**
         * The encrypted entropy of the wallet to import.
         */
        ciphertext: string;
        /**
         * The base64-encoded encapsulated key that was generated during encryption, for
         * use during decryption inside the TEE.
         */
        encapsulated_key: string;
        /**
         * The encryption type of the wallet to import. Currently only supports `HPKE`.
         */
        encryption_type: 'HPKE';
        /**
         * The entropy type of the wallet to import.
         */
        entropy_type: 'hd';
        /**
         * The index of the wallet to import.
         */
        index: number;
    }
    interface PrivateKeySubmitInput {
        /**
         * The address of the wallet to import.
         */
        address: string;
        /**
         * The chain type of the wallet to import. Currently supports `ethereum` and
         * `solana`.
         */
        chain_type: 'ethereum' | 'solana';
        /**
         * The encrypted entropy of the wallet to import.
         */
        ciphertext: string;
        /**
         * The base64-encoded encapsulated key that was generated during encryption, for
         * use during decryption inside the TEE.
         */
        encapsulated_key: string;
        /**
         * The encryption type of the wallet to import. Currently only supports `HPKE`.
         */
        encryption_type: 'HPKE';
        entropy_type: 'private-key';
    }
    interface AdditionalSigner {
        signer_id: string;
        override_policy_ids?: Array<string>;
    }
    interface UserID {
        user_id: string;
    }
    interface PublicKey {
        public_key: string;
    }
}
export interface WalletUpdateParams {
    /**
     * Body param: Additional signers for the wallet.
     */
    additional_signers?: Array<WalletUpdateParams.AdditionalSigner>;
    /**
     * Body param: The owner of the resource. If you provide this, do not specify an
     * owner_id as it will be generated automatically. When updating a wallet, you can
     * set the owner to null to remove the owner.
     */
    owner?: WalletUpdateParams.PublicKeyOwner | WalletUpdateParams.UserOwner | null;
    /**
     * Body param: The key quorum ID to set as the owner of the resource. If you
     * provide this, do not specify an owner.
     */
    owner_id?: string | null;
    /**
     * Body param: New policy IDs to enforce on the wallet. Currently, only one policy
     * is supported per wallet.
     */
    policy_ids?: Array<string>;
    /**
     * Header param: Request authorization signature. If multiple signatures are
     * required, they should be comma separated.
     */
    'privy-authorization-signature'?: string;
}
export declare namespace WalletUpdateParams {
    interface AdditionalSigner {
        override_policy_ids: Array<string>;
        signer_id: string;
    }
    /**
     * The P-256 public key of the owner of the resource. If you provide this, do not
     * specify an owner_id as it will be generated automatically.
     */
    interface PublicKeyOwner {
        public_key: string;
    }
    /**
     * The user ID of the owner of the resource. The user must already exist, and this
     * value must start with "did:privy:". If you provide this, do not specify an
     * owner_id as it will be generated automatically.
     */
    interface UserOwner {
        user_id: string;
    }
}
export interface WalletAuthenticateWithJwtParams {
    /**
     * The user's JWT, to be used to authenticate the user.
     */
    user_jwt: string;
    /**
     * The encryption type for the authentication response. Currently only supports
     * HPKE.
     */
    encryption_type?: 'HPKE';
    /**
     * The public key of your ECDH keypair, in base64-encoded, SPKI-format, whose
     * private key will be able to decrypt the session key.
     */
    recipient_public_key?: string;
}
export interface WalletCreateWalletsWithRecoveryParams {
    primary_signer: WalletCreateWalletsWithRecoveryParams.PrimarySigner;
    recovery_user: WalletCreateWalletsWithRecoveryParams.RecoveryUser;
    wallets: Array<WalletCreateWalletsWithRecoveryParams.Wallet>;
}
export declare namespace WalletCreateWalletsWithRecoveryParams {
    interface PrimarySigner {
        /**
         * The JWT subject ID of the user.
         */
        subject_id: string;
    }
    interface RecoveryUser {
        linked_accounts: Array<RecoveryUser.UnionMember0 | RecoveryUser.UnionMember1>;
    }
    namespace RecoveryUser {
        interface UnionMember0 {
            /**
             * The email address of the user.
             */
            address: string;
            type: 'email';
        }
        interface UnionMember1 {
            /**
             * The JWT subject ID of the user.
             */
            custom_user_id: string;
            type: 'custom_auth';
        }
    }
    interface Wallet {
        /**
         * Chain type of the wallet
         */
        chain_type: 'solana' | 'ethereum' | 'cosmos' | 'stellar' | 'sui' | 'tron' | 'bitcoin-segwit' | 'near' | 'spark' | 'ton' | 'starknet' | 'movement';
        /**
         * List of policy IDs for policies that should be enforced on the wallet.
         * Currently, only one policy is supported per wallet.
         */
        policy_ids?: Array<string>;
    }
}
export declare namespace Wallets {
    export { type Wallet as Wallet, type WalletExportResponse as WalletExportResponse, type WalletInitImportResponse as WalletInitImportResponse, type WalletRawSignResponse as WalletRawSignResponse, type WalletRpcResponse as WalletRpcResponse, type WalletAuthenticateWithJwtResponse as WalletAuthenticateWithJwtResponse, type WalletCreateWalletsWithRecoveryResponse as WalletCreateWalletsWithRecoveryResponse, type WalletsCursor as WalletsCursor, type WalletCreateParams as WalletCreateParams, type WalletListParams as WalletListParams, type WalletExportParams as WalletExportParams, type WalletInitImportParams as WalletInitImportParams, type WalletRawSignParams as WalletRawSignParams, type WalletRpcParams as WalletRpcParams, type WalletSubmitImportParams as WalletSubmitImportParams, type WalletUpdateParams as WalletUpdateParams, type WalletAuthenticateWithJwtParams as WalletAuthenticateWithJwtParams, type WalletCreateWalletsWithRecoveryParams as WalletCreateWalletsWithRecoveryParams, };
    export { Transactions as Transactions, type TransactionGetResponse as TransactionGetResponse, type TransactionGetParams as TransactionGetParams, };
    export { Balance as Balance, type BalanceGetResponse as BalanceGetResponse, type BalanceGetParams as BalanceGetParams, };
}
//# sourceMappingURL=wallets.d.ts.map