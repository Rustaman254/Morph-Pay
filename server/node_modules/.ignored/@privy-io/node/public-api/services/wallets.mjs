import { PrivyAPIError } from "../../core/error.mjs";
import { generateAuthorizationSignatures } from "../../lib/authorization.mjs";
import { setupHPKERecipient, setupHPKESender } from "../../lib/cryptography.mjs";
import { entropyToBytes } from "../../lib/wallet-entropy.mjs";
import { Wallets, } from "../../resources.mjs";
import { PrivyEthereumService } from "./ethereum.mjs";
import { PrivySolanaService } from "./solana.mjs";
export class PrivyWalletsService extends Wallets {
    constructor(privyApiClient, privyClient) {
        super(privyApiClient);
        this.privyClient = privyClient;
        this.ethereumService = new PrivyEthereumService(this);
        this.solanaService = new PrivySolanaService(this);
    }
    ethereum() {
        return this.ethereumService;
    }
    solana() {
        return this.solanaService;
    }
    async rpc(walletId, { authorization_context: authorizationContext = {}, idempotency_key: idempotencyKey, ...params }) {
        const authorizationSignaturesHeader = await generateAuthorizationSignatures(this.privyClient, {
            authorizationContext,
            input: {
                version: 1,
                method: 'POST',
                url: `${this._client.baseURL}/v1/wallets/${walletId}/rpc`,
                body: params,
                headers: {
                    'privy-app-id': this._client.appID,
                    ...(idempotencyKey && { 'privy-idempotency-key': idempotencyKey }),
                },
            },
        });
        return await this._rpc(walletId, {
            ...params,
            'privy-authorization-signature': authorizationSignaturesHeader.join(','),
            ...(idempotencyKey && { 'privy-idempotency-key': idempotencyKey }),
        });
    }
    async rawSign(walletId, { authorization_context: authorizationContext = {}, idempotency_key: idempotencyKey, ...params }) {
        const authorizationSignaturesHeader = await generateAuthorizationSignatures(this.privyClient, {
            authorizationContext,
            input: {
                version: 1,
                method: 'POST',
                url: `${this._client.baseURL}/v1/wallets/${walletId}/raw_sign`,
                body: params,
                headers: {
                    'privy-app-id': this._client.appID,
                    ...(idempotencyKey && { 'privy-idempotency-key': idempotencyKey }),
                },
            },
        });
        const response = await this._rawSign(walletId, {
            ...params,
            'privy-authorization-signature': authorizationSignaturesHeader.join(','),
            ...(idempotencyKey && { 'privy-idempotency-key': idempotencyKey }),
        });
        return response.data;
    }
    async update(walletId, { authorization_context: authorizationContext = {}, ...params }) {
        const authorizationSignaturesHeader = await generateAuthorizationSignatures(this.privyClient, {
            authorizationContext,
            input: {
                version: 1,
                method: 'PATCH',
                url: `${this._client.baseURL}/v1/wallets/${walletId}`,
                body: params,
                headers: {
                    'privy-app-id': this._client.appID,
                },
            },
        });
        const response = await this._update(walletId, {
            ...params,
            'privy-authorization-signature': authorizationSignaturesHeader.join(','),
        });
        return response;
    }
    async export(walletId, { authorization_context: authorizationContext = {}, ...outerParams }) {
        const { publicKeySpki, decryptPayload } = await setupHPKERecipient();
        const params = {
            ...outerParams,
            encryption_type: 'HPKE',
            // We fall back to `Buffer` here as Uint8Array.toBase64 is not widely supported yet
            recipient_public_key: Buffer.from(publicKeySpki).toString('base64'),
        };
        const authorizationSignaturesHeader = await generateAuthorizationSignatures(this.privyClient, {
            authorizationContext,
            input: {
                version: 1,
                method: 'POST',
                url: `${this._client.baseURL}/v1/wallets/${walletId}/export`,
                body: params,
                headers: {
                    'privy-app-id': this._client.appID,
                },
            },
        });
        const response = await this._export(walletId, {
            ...params,
            'privy-authorization-signature': authorizationSignaturesHeader.join(','),
        });
        const decryptedPrivateKey = await decryptPayload(
        // We fall back to `Buffer` here as Uint8Array.fromBase64 is not widely supported yet
        Buffer.from(response.encapsulated_key, 'base64'), Buffer.from(response.ciphertext, 'base64'));
        const privateKey = new TextDecoder().decode(decryptedPrivateKey);
        return { private_key: privateKey };
    }
    async import({ wallet: { private_key, ...wallet }, ...params }) {
        const hpkeSender = await setupHPKESender();
        const privateKeyBytes = entropyToBytes({
            entropy: private_key,
            entropyType: wallet.entropy_type,
            chainType: wallet.chain_type,
        });
        const initResponse = await this._initImport({
            ...wallet,
            encryption_type: 'HPKE',
        });
        if (initResponse.encryption_type !== 'HPKE') {
            throw new PrivyAPIError(`Invalid encryption type: ${initResponse.encryption_type}`);
        }
        // We fall back to `Buffer` here as Uint8Array.fromBase64 is not widely supported yet
        const encryptionPublicKey = Buffer.from(initResponse.encryption_public_key, 'base64');
        const { encapsulatedKey, ciphertext } = await hpkeSender.encryptPayload(encryptionPublicKey, privateKeyBytes);
        const submitResponse = await this._submitImport({
            ...params,
            wallet: {
                ...wallet,
                encryption_type: 'HPKE',
                // We fall back to `Buffer` here as Uint8Array.toBase64 is not widely supported yet
                encapsulated_key: Buffer.from(encapsulatedKey).toString('base64'),
                ciphertext: Buffer.from(ciphertext).toString('base64'),
            },
        });
        return submitResponse;
    }
}
//# sourceMappingURL=wallets.mjs.map