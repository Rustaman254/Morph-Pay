"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivyWalletsService = void 0;
const error_1 = require("../../core/error.js");
const authorization_1 = require("../../lib/authorization.js");
const cryptography_1 = require("../../lib/cryptography.js");
const wallet_entropy_1 = require("../../lib/wallet-entropy.js");
const resources_1 = require("../../resources.js");
const ethereum_1 = require("./ethereum.js");
const solana_1 = require("./solana.js");
class PrivyWalletsService extends resources_1.Wallets {
    constructor(privyApiClient, privyClient) {
        super(privyApiClient);
        this.privyClient = privyClient;
        this.ethereumService = new ethereum_1.PrivyEthereumService(this);
        this.solanaService = new solana_1.PrivySolanaService(this);
    }
    ethereum() {
        return this.ethereumService;
    }
    solana() {
        return this.solanaService;
    }
    async rpc(walletId, { authorization_context: authorizationContext = {}, idempotency_key: idempotencyKey, ...params }) {
        const authorizationSignaturesHeader = await (0, authorization_1.generateAuthorizationSignatures)(this.privyClient, {
            authorizationContext,
            input: {
                version: 1,
                method: 'POST',
                url: `${this._client.baseURL}/v1/wallets/${walletId}/rpc`,
                body: params,
                headers: {
                    'privy-app-id': this._client.appID,
                    ...(idempotencyKey && { 'privy-idempotency-key': idempotencyKey }),
                },
            },
        });
        return await this._rpc(walletId, {
            ...params,
            'privy-authorization-signature': authorizationSignaturesHeader.join(','),
            ...(idempotencyKey && { 'privy-idempotency-key': idempotencyKey }),
        });
    }
    async rawSign(walletId, { authorization_context: authorizationContext = {}, idempotency_key: idempotencyKey, ...params }) {
        const authorizationSignaturesHeader = await (0, authorization_1.generateAuthorizationSignatures)(this.privyClient, {
            authorizationContext,
            input: {
                version: 1,
                method: 'POST',
                url: `${this._client.baseURL}/v1/wallets/${walletId}/raw_sign`,
                body: params,
                headers: {
                    'privy-app-id': this._client.appID,
                    ...(idempotencyKey && { 'privy-idempotency-key': idempotencyKey }),
                },
            },
        });
        const response = await this._rawSign(walletId, {
            ...params,
            'privy-authorization-signature': authorizationSignaturesHeader.join(','),
            ...(idempotencyKey && { 'privy-idempotency-key': idempotencyKey }),
        });
        return response.data;
    }
    async update(walletId, { authorization_context: authorizationContext = {}, ...params }) {
        const authorizationSignaturesHeader = await (0, authorization_1.generateAuthorizationSignatures)(this.privyClient, {
            authorizationContext,
            input: {
                version: 1,
                method: 'PATCH',
                url: `${this._client.baseURL}/v1/wallets/${walletId}`,
                body: params,
                headers: {
                    'privy-app-id': this._client.appID,
                },
            },
        });
        const response = await this._update(walletId, {
            ...params,
            'privy-authorization-signature': authorizationSignaturesHeader.join(','),
        });
        return response;
    }
    async export(walletId, { authorization_context: authorizationContext = {}, ...outerParams }) {
        const { publicKeySpki, decryptPayload } = await (0, cryptography_1.setupHPKERecipient)();
        const params = {
            ...outerParams,
            encryption_type: 'HPKE',
            // We fall back to `Buffer` here as Uint8Array.toBase64 is not widely supported yet
            recipient_public_key: Buffer.from(publicKeySpki).toString('base64'),
        };
        const authorizationSignaturesHeader = await (0, authorization_1.generateAuthorizationSignatures)(this.privyClient, {
            authorizationContext,
            input: {
                version: 1,
                method: 'POST',
                url: `${this._client.baseURL}/v1/wallets/${walletId}/export`,
                body: params,
                headers: {
                    'privy-app-id': this._client.appID,
                },
            },
        });
        const response = await this._export(walletId, {
            ...params,
            'privy-authorization-signature': authorizationSignaturesHeader.join(','),
        });
        const decryptedPrivateKey = await decryptPayload(
        // We fall back to `Buffer` here as Uint8Array.fromBase64 is not widely supported yet
        Buffer.from(response.encapsulated_key, 'base64'), Buffer.from(response.ciphertext, 'base64'));
        const privateKey = new TextDecoder().decode(decryptedPrivateKey);
        return { private_key: privateKey };
    }
    async import({ wallet: { private_key, ...wallet }, ...params }) {
        const hpkeSender = await (0, cryptography_1.setupHPKESender)();
        const privateKeyBytes = (0, wallet_entropy_1.entropyToBytes)({
            entropy: private_key,
            entropyType: wallet.entropy_type,
            chainType: wallet.chain_type,
        });
        const initResponse = await this._initImport({
            ...wallet,
            encryption_type: 'HPKE',
        });
        if (initResponse.encryption_type !== 'HPKE') {
            throw new error_1.PrivyAPIError(`Invalid encryption type: ${initResponse.encryption_type}`);
        }
        // We fall back to `Buffer` here as Uint8Array.fromBase64 is not widely supported yet
        const encryptionPublicKey = Buffer.from(initResponse.encryption_public_key, 'base64');
        const { encapsulatedKey, ciphertext } = await hpkeSender.encryptPayload(encryptionPublicKey, privateKeyBytes);
        const submitResponse = await this._submitImport({
            ...params,
            wallet: {
                ...wallet,
                encryption_type: 'HPKE',
                // We fall back to `Buffer` here as Uint8Array.toBase64 is not widely supported yet
                encapsulated_key: Buffer.from(encapsulatedKey).toString('base64'),
                ciphertext: Buffer.from(ciphertext).toString('base64'),
            },
        });
        return submitResponse;
    }
}
exports.PrivyWalletsService = PrivyWalletsService;
//# sourceMappingURL=wallets.js.map