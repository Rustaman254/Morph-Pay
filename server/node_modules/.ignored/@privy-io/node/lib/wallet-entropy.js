"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.entropyToBytes = entropyToBytes;
const base_1 = require("@scure/base");
const error_1 = require("../error.js");
function entropyToBytes(wallet) {
    const { entropy, entropyType, chainType } = wallet;
    if (typeof entropy !== 'string') {
        // If a straight entropy byte array is provided, return it
        return entropy;
    }
    switch (entropyType) {
        case 'hd':
            // HD entropy is a BIP39 mnemonic that can be encoded as utf-8
            return new TextEncoder().encode(entropy);
        case 'private-key':
            if (chainType === 'ethereum') {
                try {
                    // Private key strings are hex encoded for Ethereum
                    const entropyWithout0x = entropy.startsWith('0x') ? entropy.slice(2) : entropy;
                    // We fall back to `Buffer` here as Uint8Array.fromHex is not widely supported yet
                    return new Uint8Array(Buffer.from(entropyWithout0x, 'hex'));
                }
                catch (error) {
                    throw new error_1.PrivyAPIError(`Invalid private key: Ethereum entropy must be hex encoded`);
                }
            }
            if (chainType === 'solana') {
                try {
                    // Private key strings are base58 encoded for Solana
                    return base_1.base58.decode(entropy);
                }
                catch (error) {
                    throw new error_1.PrivyAPIError(`Invalid private key: Solana entropy must be base58 encoded`);
                }
            }
            // This should be unreachable, so we check with `satisfies never`
            throw new error_1.PrivyAPIError(`Invalid chain type for imports: ${chainType}`);
        default:
            // This should be unreachable, so we check with `satisfies never`
            throw new error_1.PrivyAPIError(`Invalid entropy type: ${entropyType}`);
    }
}
//# sourceMappingURL=wallet-entropy.js.map