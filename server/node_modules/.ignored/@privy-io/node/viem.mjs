import { toAccount, } from 'viem/accounts';
import { toHex } from 'viem/utils';
import { PrivyAPIError } from "./core/error.mjs";
/**
 * Creates a viem `Account` instance for a Privy wallet given its ID, which can be used to sign
 * messages and send transactions with the wallet.
 *
 * @param client instance of the Privy client.
 * @param input an object specifying the details of the wallet to create the viem account for.
 * @returns viem `Account` instance for the wallet.
 */
export function createViemAccount(client, { walletId, address, authorizationContext }) {
    return toAccount({
        address: address,
        sign: async ({ hash }) => {
            const response = await client
                .wallets()
                .ethereum()
                .signSecp256k1(walletId, {
                params: { hash },
                ...(authorizationContext ? { authorization_context: authorizationContext } : {}),
            });
            return response.signature;
        },
        signMessage: async ({ message }) => {
            const response = await client
                .wallets()
                .ethereum()
                .signMessage(walletId, {
                message: formatViemPersonalSignMessage(message),
                ...(authorizationContext ? { authorization_context: authorizationContext } : {}),
            });
            return response.signature;
        },
        signTypedData: async (typedData) => {
            const { message, domain, types, primaryType } = replaceBigInts(typedData, toHex);
            // Viem accepts undefined `domain`, `message`, and `types` in this method
            // though those are required per the EIP712 spec.
            if (!domain)
                throw new PrivyAPIError('typedData.domain must be defined');
            if (!message)
                throw new PrivyAPIError('typedData.message must be defined');
            if (!types)
                throw new PrivyAPIError('typedData.message must be defined');
            const { signature } = await client
                .wallets()
                .ethereum()
                .signTypedData(walletId, {
                params: {
                    typed_data: { domain, message, primary_type: primaryType, types: types },
                },
                ...(authorizationContext ? { authorization_context: authorizationContext } : {}),
            });
            return signature;
        },
        signTransaction: async (transaction) => {
            const { signed_transaction: signedTransaction } = await client
                .wallets()
                .ethereum()
                .signTransaction(walletId, {
                params: { transaction: formatViemTransaction(transaction) },
                ...(authorizationContext ? { authorization_context: authorizationContext } : {}),
            });
            return signedTransaction;
        },
        signAuthorization: async (parameters) => {
            const { authorization } = await client
                .wallets()
                .ethereum()
                .sign7702Authorization(walletId, {
                params: {
                    contract: (parameters.contractAddress ?? parameters.address),
                    chain_id: parameters.chainId,
                    nonce: parameters.nonce,
                },
                ...(authorizationContext ? { authorization_context: authorizationContext } : {}),
            });
            return {
                address: authorization.contract,
                nonce: Number(authorization.nonce),
                chainId: Number(authorization.chain_id),
                yParity: authorization.y_parity,
                r: authorization.r,
                s: authorization.s,
            };
        },
    });
}
/**
 * Formats a viem transaction type to the JSON-RPC transaction type:
 * - 'legacy' -> 0
 * - 'eip2930' -> 1
 * - 'eip1559' or undefined -> 2. This is the default EVM transaction type.
 * - 'eip4844' -> 3 in theory, but will throw an error as we do not support this yet.
 * - 'eip7702' -> 4 in theory, but will throw an error as we do not support this yet
 * @param type viem transaction type
 * @returns 0 | 1 | 2
 */
const formatViemTransactionType = (type) => {
    if (type === 'legacy') {
        return 0;
    }
    else if (type === 'eip2930') {
        return 1;
    }
    else if (type == 'eip1559' || typeof type === 'undefined') {
        // Type 2 (EIP-1559) is the default transaction type
        return 2;
    }
    else {
        // We do not yet support EIP4844 (type 3) and EIP7702 (type 4) transaction types
        throw new PrivyAPIError('EIP4844 and EIP7702 transaction types are not yet supported.');
    }
};
/**
 * Formats viem quantities, which are represented as `bigint | undefined` to our internal
 * `Quantity` type. This is done by converting bigints into a hexstring.
 *
 * @param input {bigint | undefined} bigint quantity to format
 * @returns input as hex string
 */
const formatViemQuantity = (input) => {
    return `0x${input.toString(16)}`;
};
/**
 * Formats a `message` input to viem's `signMessage` function to the format needed for our wallet API.
 *
 * If the `message` is a string, we use it directly.
 *
 * If the `message` is an object containing a `raw` field, it indicates that the use case is signing raw bytes,
 * in which case we convert `message.raw` into a `Uint8Array` before passing it to our own `signMessage`
 * @param message input to viem's `signMessage` function
 * @returns message as a utf-8 `string` or `Uint8Array`
 */
const formatViemPersonalSignMessage = (message) => {
    if (typeof message === 'string')
        return message;
    if (typeof message.raw === 'string') {
        // We `.slice(2)` to remove the `0x` prefix
        return Uint8Array.from(Buffer.from(message.raw.slice(2), 'hex'));
    }
    else {
        return message.raw;
    }
};
/**
 * Formats a viem transaction into our internal transaction type. For the most part, this converts
 * bigints to hexstrings so they can be passed over the wire.
 *
 * @param tx input to viem's `sendTransaction` function
 * @returns transaction {EthereumSignTransactionInputType} as our own type
 */
const formatViemTransaction = (tx) => {
    return {
        type: formatViemTransactionType(tx.type),
        ...(tx.to ? { to: tx.to } : {}),
        ...(tx.nonce ? { nonce: tx.nonce } : {}),
        ...(tx.chainId ? { chain_id: tx.chainId } : {}),
        ...(tx.data ? { data: tx.data } : {}),
        ...(tx.value ? { value: formatViemQuantity(tx.value) } : {}),
        ...(tx.gas ? { gas_limit: formatViemQuantity(tx.gas) } : {}),
        ...(tx.gasPrice ? { gas_price: formatViemQuantity(tx.gasPrice) } : {}),
        ...(tx.maxFeePerGas ? { max_fee_per_gas: formatViemQuantity(tx.maxFeePerGas) } : {}),
        ...(tx.maxPriorityFeePerGas ?
            { max_priority_fee_per_gas: formatViemQuantity(tx.maxPriorityFeePerGas) }
            : {}),
    };
};
const replaceBigInts = (obj, replacer) => {
    if (typeof obj === 'bigint')
        return replacer(obj);
    if (Array.isArray(obj)) {
        return obj.map((x) => replaceBigInts(x, replacer));
    }
    if (obj && typeof obj === 'object') {
        return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, replaceBigInts(v, replacer)]));
    }
    return obj;
};
//# sourceMappingURL=viem.mjs.map