import { p256 } from '@noble/curves/nist';
import { sha256 } from '@noble/hashes/sha2';
import canonicalize from 'canonicalize';
import { PrivyAPIError } from "../core/error.mjs";
import { importPKCS8PrivateKey } from "./cryptography.mjs";
/**
 * Formats the request payload into the expected authorization payload, canconicalizes it,
 * and encodes the JSON string into bytes.
 *
 * @param request The request to be formatted.
 * @return The raw bytes representing the authorization payload.
 */
export function formatRequestForAuthorizationSignature(input) {
    const body = input.body;
    if (typeof body === 'object' && body !== null && Object.keys(body).length === 0) {
        // This is a special case, where if the body is empty, we want to serialize it
        // as an empty string.
        input.body = '';
    }
    const serializedInput = canonicalize(input);
    if (!serializedInput) {
        throw new PrivyAPIError('Failed to serialize request for authorization signature');
    }
    return new TextEncoder().encode(serializedInput);
}
/**
 * Generates authorization signatures from the given authorization context and signable request.
 * This method handles JWT exchange and private key signing.
 *
 * Manual signing of requests is intended for advanced use cases.
 *
 * @param authorizationContext The authorization context containing JWTs, private keys, and signatures.
 * @param input The request payload to sign.
 * @returns An array of authorization signatures.
 */
export async function generateAuthorizationSignatures(client, { authorizationContext, input, }) {
    const payload = formatRequestForAuthorizationSignature(input);
    const userJwts = authorizationContext.user_jwts ?? [];
    let userKeys = [];
    if (userJwts.length > 0) {
        userKeys = await Promise.all(userJwts.map((jwt) => client._jwtExchange().exchangeJwtForAuthorizationKey(jwt)));
    }
    /** These are the private keys provided by the caller, either directly or via JWT exchange */
    const privateKeys = [...(authorizationContext.authorization_private_keys ?? []), ...userKeys];
    /** These are the signatures calculated from the private keys */
    const calculatedSignatures = privateKeys.map((sk) => generateAuthorizationSignature({ authorizationPrivateKey: sk, input: payload }));
    /** These are the signatures calculated externally from the given sign functions */
    const signFnSignatures = await Promise.all((authorizationContext.sign_fns ?? []).map((signFn) => signFn(payload)));
    /** These are the signatures provided directly by the caller */
    const providedRawSignatures = authorizationContext.signatures ?? [];
    return [...providedRawSignatures, ...calculatedSignatures, ...signFnSignatures];
}
/**
 * Signs the given request with the provided private key.
 *
 * @param authorizationPrivateKey The base64-encoded PKCS8-formatted private key, with no PEM headers.
 * @param input The request payload to sign, or one serialized using {@link formatRequestForAuthorizationSignature}.
 * @return The authorization signature.
 */
export function generateAuthorizationSignature({ authorizationPrivateKey, input, }) {
    const payload = input instanceof Uint8Array ? input : formatRequestForAuthorizationSignature(input);
    const privateKey = importPKCS8PrivateKey(authorizationPrivateKey);
    const signature = p256.sign(sha256(payload), privateKey).toBytes('der');
    // We fall back to `Buffer` here as Uint8Array.toBase64 is not widely supported yet
    return Buffer.from(signature).toString('base64');
}
//# sourceMappingURL=authorization.mjs.map