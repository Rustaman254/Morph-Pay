"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AUTHORIZATION_PRIVATE_KEY_PREFIX = exports.WALLET_API_PRIVATE_KEY_PREFIX = void 0;
exports.importPKCS8PrivateKey = importPKCS8PrivateKey;
exports.setupHPKERecipient = setupHPKERecipient;
exports.setupHPKESender = setupHPKESender;
const chacha20poly1305_1 = require("@hpke/chacha20poly1305");
const core_1 = require("@hpke/core");
const nist_1 = require("@noble/curves/nist");
/**
 * Imports a P-256 private key for use with the `@noble/curves` library.
 *
 * @param privateKey - A base64-encoded PKCS8-formatted private key, with no PEM headers.
 * @returns A private key object for the P-256 curve.
 * @internal
 */
function importPKCS8PrivateKey(privateKey) {
    const strippedPrivateKey = privateKey
        .replace(exports.AUTHORIZATION_PRIVATE_KEY_PREFIX, '')
        .replace(exports.WALLET_API_PRIVATE_KEY_PREFIX, '');
    // We fall back to `Buffer` here as Uint8Array.fromBase64 is not widely supported yet
    const pkcs8Bytes = Buffer.from(strippedPrivateKey, 'base64');
    const privateKeyStart = pkcs8Bytes.indexOf(Buffer.from([0x04, 0x20]));
    if (privateKeyStart === -1) {
        throw new Error('Invalid wallet authorization private key');
    }
    const privateKeyBytes = pkcs8Bytes.subarray(privateKeyStart + 2, privateKeyStart + 34);
    return nist_1.p256.Point.Fn.fromBytes(privateKeyBytes);
}
/**
 * Sets up HPKE for securely requesting a payload (as the recipient)
 * from a sender (e.g. the Privy API).
 * @returns The HPKE receiver object.
 * @internal
 */
async function setupHPKERecipient() {
    const suite = new core_1.CipherSuite({
        kem: new core_1.DhkemP256HkdfSha256(),
        kdf: new core_1.HkdfSha256(),
        aead: new chacha20poly1305_1.Chacha20Poly1305(),
    });
    const keypair = await suite.kem.generateKeyPair();
    const publicKeySpki = await crypto.subtle.exportKey('spki', keypair.publicKey);
    return {
        publicKeySpki: new Uint8Array(publicKeySpki),
        decryptPayload: async (encapsulatedKey, ciphertext) => {
            const recipient = await suite.createRecipientContext({
                recipientKey: keypair.privateKey,
                enc: encapsulatedKey,
            });
            const decodedBytes = await recipient.open(ciphertext);
            return new Uint8Array(decodedBytes);
        },
    };
}
async function setupHPKESender() {
    const suite = new core_1.CipherSuite({
        kem: new core_1.DhkemP256HkdfSha256(),
        kdf: new core_1.HkdfSha256(),
        aead: new chacha20poly1305_1.Chacha20Poly1305(),
    });
    return {
        encryptPayload: async (publicKey, payload) => {
            const recipientPublicKey = await suite.kem.deserializePublicKey(publicKey);
            const sender = await suite.createSenderContext({
                recipientPublicKey,
            });
            const ciphertext = await sender.seal(payload);
            return {
                ciphertext: new Uint8Array(ciphertext),
                encapsulatedKey: new Uint8Array(sender.enc),
            };
        },
    };
}
/** This prefix is no longer used, but we need to support existing keys */
exports.WALLET_API_PRIVATE_KEY_PREFIX = 'wallet-api:';
exports.AUTHORIZATION_PRIVATE_KEY_PREFIX = 'wallet-auth:';
//# sourceMappingURL=cryptography.js.map